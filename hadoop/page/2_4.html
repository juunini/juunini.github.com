이 전까지는 패키지를 만들고 파일을 import 시키는 방법을 몰라서 쌩으로 했지만,<br>
이젠 알게되어서 파일을 만들고 import 시켜서 하는 방법을 알려드리면서 진행하도록 하겠습니다.<br>
이번 글의 파일은 전부 hadoop-examples 폴더 내에 sort 라는 폴더를 만들어서 진행하도록 하겠습니다.<br>
<br>
일단 이착륙 예제 맨 앞에 나왔던 공통클래스를 작성하도록 하겠습니다.<br>

<terminal>
<color4>package</color4> <color2>Airline</color2>;

<color4>import</color4> <color2>org.apache.hadoop.io.Text</color2>;

<color2>public class</color2> AirlineParser {
    <color2>private int</color2> year;
    <color2>private int</color2> month;

    <color2>private int</color2> departureDelayTime = <color2>0</color2>;
    <color2>private int</color2> arriveDelayTime = <color2>0</color2>;
    <color2>private int</color2> distance = <color2>0</color2>;

    <color2>private boolean</color2> arriveDelayAvailable = <color2>true</color2>;
    <color2>private boolean</color2> departureDelayAvailable = <color2>true</color2>;
    <color2>private boolean</color2> distanceAvailable = <color2>true</color2>;

    <color2>private String</color2> uniqueCarrier;

    <color2>public</color2> <color3>AirlineParser</color3>(<color2>Text</color2> text) {
        <color6>try</color6>{
            <color2>String</color2>[] column = <color4>text</color4>.<color3>toString</color3>().<color3>split</color3>(<color7>","</color7>);

            year = <color4>Integer</color4>.<color3>parseInt</color3>(column[<color2>0</color2>]);
            month = <color4>Integer</color4>.<color3>parseInt</color3>(column[<color2>1</color2>]);
            day = <color4>Integer</color4>.<color3>parseInt</color3>(column[<color2>2</color2>]);

            uniqueCarrier = column[<color2>8</color2>];

            <color6>if</color6> (!column[<color2>15</color2>].<color3>equals</color3>(<color7>"NA"</color7>)) {
                departureDelayTime = <color4>Integer</color4>.<color3>parseInt</color3>(column[<color2>15</color2>]);
            } <color6>else</color6> {
                departureDelayAvailable = <color2>false</color2>;
            }

            <color6>if</color6> (!column[<color2>14</color2>].<color3>equals</color3>(<color7>"NA"</color7>)) {
                arriveDelayTime = <color4>Integer</color4>.<color3>parseInt</color3>(column[<color2>14</color2>]);
            } <color6>else</color6> {
                arriveDelayAvailable = <color2>false</color2>;
            }

            <color6>if</color6> (!column[<color2>18</color2>].<color3>equals</color3>(<color7>"NA"</color7>)) {
                distanceTime = <color4>Integer</color4>.<color3>parseInt</color3>(column[<color2>18</color2>]);
            } <color6>else</color6> {
                distanceAvailable = <color2>false</color2>;
            }

        } <color6>catch</color6> (<color2>Exception</color2> e) {
            <color4>System</color4>.<color4>out</color4>.<color3>println</color3>(<color7>"Error parsing a record : "</color7> + e.<color3>getMessage</color3>());
        }
    }

    <color2>public int</color2> <color3>getYear</color3>() { <color6>return</color6> year; }
    <color2>public int</color2> <color3>getMonth</color3>() { <color6>return</color6> month; }
    <color2>public int</color2> <color3>getDay</color3>() { <color6>return</color6> day; }

    <color2>public int</color2> <color3>getDepartureDelayTime</color3>() { <color6>return</color6> departureDelayTime; }
    <color2>public int</color2> <color3>getArriveDelayTime</color3>() { <color6>return</color6> arriveDelayTime; }
    <color2>public int</color2> <color3>getDistance</color3>() { <color6>return</color6> distance; }

    <color2>public boolean</color2> <color3>isDepartureDelayAvailable</color3>() { <color6>return</color6> departureDelayAvailable; }
    <color2>public boolean</color2> <color3>isArriveDelayAvailable</color3>() { <color6>return</color6> arriveDelayAvailable; }
    <color2>public boolean</color2> <color3>isDistanceAvailable</color3>() { <color6>return</color6> distanceAvailable; }

    <color2>public String</color2> <color3>getUniqueCarrier</color3>() { <color6>return</color6> uniqueCarrier; }
}
</terminal>

이렇게 작성합니다.<br>
그리고 우리가 이전까진 자바 파일을 컴파일 할 때 <color4>javac -cp $HADOOP_HOME/hadoop-core*.jar *.java</color4> 이런식으로 했잖아요?<br>
그런데 패키지를 만들고 파일을 import 시킬려면 <color4>javac -cp $HADOOP_HOME/hadoop-core*.jar -d . *.java</color4> 이런식으로 해야합니다.<br>
아무튼 더 자세한건 진행하면서 알려드릴게요.<br>
<br>
이번에는 앞에 저게 중요한게 아니라 데이터 정렬을 다룰 예정입니다.<br>
어차피 R로 시각화 할건데 뭐가 문제냐구요?<br>
경우에 따라서는 정렬이 잘 되어있는 데이터를 요구할 경우도 있습니다.<br>
우리가 만들었던 <color4>arrival.txt</color4> 파일의 일부분을 보여드리겠습니다.<br>

<img src="/hadoop/img2/4_1.jpg" alt="">

1 다음에 10이 나온게 보이시죠?<br>
왜 1 다음에 10이 나온거지? 상식적으로 1 다음에 2가 와야 하는게 아닌가요?<br>
하지만 컴퓨터의 알고리즘상 1 다음에 10 그다음 11, 12, 2 이런식으로 오는게 맞답니다.<br>
그러니 데이터 정렬을 하는 방법을 보고 넘어갑시다.<br>
<br>
책의 180페이지부터 보면 복합키라느니 비교기라느니 어쩌고저쩌고 나오는데, 결론적으로 어떻게 쓰는지 잘 안알려주고 그냥 넘어가버립니다.<br>
그러니 제가 분석해서 어떻게 쓰는지 한번 알아보고 가겠습니다.<br>
<br>
<color4>WritableComparable.java</color4>의 일부분을 발췌하였습니다.<br>

<terminal>
private int counter;
 *       private long timestamp;
 *       
 *       public void write(DataOutput out) throws IOException {
 *         out.writeInt(counter);
 *         out.writeLong(timestamp);
 *       }
 *       
 *       public void readFields(DataInput in) throws IOException {
 *         counter = in.readInt();
 *         timestamp = in.readLong();
 *       }
 *       
 *       public int compareTo(MyWritableComparable w) {
 *         int thisValue = this.value;
 *         int thatValue = ((IntWritable)o).value;
 *         return (thisValue &lt; thatValue ? -1 : (thisValue==thatValue ? 0 : 1));
 *       }
</terminal>

보면 write, readFields, compareTo 함수를 오버라이드 할 것을 명시하고 있습니다.<br>
<br>
<color4>DateKey.java</color4>

<terminal>
package Airline;

import org.apache.hadoop.io.WritableComparable;
import org.apache.hadoop.io.WritableUtils;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

public class DateKey implements WritableComparable&lt;DateKey&gt; {

    private String year;   // 왜 String으로 주냐면, 앞에 D와 A의 구분자를 넣어줄 것 이기 때문입니다. 그게 아니면 Integer로 쓰겠죠.
    private Integer month;

    public DateKey() {}

    public DateKey (String year, Integer month) {
        this.year = year;
        this.month = month;
    }

    public String getYear() { return year; }
    public Integer getMonth() { return month; }
    public void setYear(String year) { this.year = year; }
    public void setMonth(Integer month) { this.month = month; }

    @Override
    public String toString() {
        return (new StringBuilder()).append(year).append("\t").append(month).toString();    // 책에는 중간에 콤마가 있지만 저는 R의 작업 효용상 탭으로 구분하겠습니다.
    }   // 결과를 String형태로 변환

    @Override
    public void readFields(DataInput in) throws IOException {
        year = WritableUtils.readString(in);  // 어차피 순서대로 읽어들여서 둘 다 int값이어도 상관없습니다.
        month = in.readInt();
    }

    @Override
    public void write(DataOutput out) throws IOException {
        WritableUtils.writeString(out, year);
        out.writeInt(month);
    }

    @Override
    public int compareTo(DateKey key) {
        int result = year.compareTo(key.year);
        if (0 == result) {
            result = month.compareTo(key.month);
        }
        return result;
    }   // 년도를 비교한 후 년도가 같으면 월을 비교함.
}
</terminal>

이렇게 하고 아래 명령어로 컴파일 해보았습니다.<br>

<terminal>
<strong>[hadoop@namenode sort]$</strong> javac -cp $HADOOP_HOME/hadoop-core-1.2.1.jar -d . *.java
</terminal>

그랬더니 <color4>Airline</color4> 이라는 폴더가 만들어지면서 거기에 class 파일이 들어갔습니다. 쩃든 컴파일은 잘 된 셈입니다.<br>
다음 파일을 작성해보겠습니다.<br>
<br>
<color4>DateKeyComparator.java</color4>

<terminal>
package Airline;

import org.apache.hadoop.io.WritableComparable;
import org.apache.hadoop.io.WritableComparator;

import Airline.DateKey; // 컴파일 해보니 이걸 안넣으면 에러가 납니다.

public class DateKeyComparator extends WritableComparator {
    protected DateKeyComparator() { // 해당 파일이 실행되면 DateKay를 곧장 불러오겠다는 의미
        super(DateKey.class, true);
    }

    // 에러문구 무시
    @SuppressWarnings("rawtypes")
    @Override
    public int compare(WritableComparable w1, WritableComparable w2) {
        DateKey k1 = (DateKey) w1;  // 강제 형 변환
        DateKey k2 = (DateKey) w2;  // 강제 형 변환

        int cmp = k1.getYear().compareTo(k2.getYear()); // 아까 왔던거랑 지금 온거랑 비교
        if (cmp != 0) { return cmp; }   // 년도를 비교해서 같지 않은 경우 해당 값을 리턴하고 종료

        return k1.getMonth() == k2.getMonth() ? 0 : (k1.getMonth() < k2.getMonth() ? -1 : 1);
        // ? 뒤에 true : false 조건이 들어갑니다.
        // 맨 처음에 참이면 0, 거짓이면 또 다른 조건문이 들어갑니다.
        // 두번 쨰 조건은 비교 대상이 작으면 -1, 크면 1 입니다.
    }
}
</terminal>

자, 여기서도 불친절한 저자양반이 4번줄을 빼멱으셨습니다.<br>
저기 주석달아놓은 4번 줄 보이시죠?<br>
뭐, 한두번도 아니니 넘어갑시다.<br>
이 파일의 내용은 줄 단위로 입력받은 연도가 저번거랑 이번거랑 같은지 비교하고, 같다면 저번거랑 이번거랑 월을 비교하는 겁니다.<br>
compartTo 함수로 구분하게 되면 1 다음에 10이 오는게 아니라 2가 오게 되죠.<br>
<br>
<color4>GroupKeyPartitioner.java</color4>

<terminal>
package Airline;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.mapreduce.Partitioner;

import Airline.DateKey; // 역시나 넣어줘야 합니다.

public class GroupKeyPartitioner extends Partitioner&lt;DateKey, IntWritable&gt; {
    
    @Override
    public int getPartition(DateKey key, IntWritable val, int numPartitions) {
        int hash = key.getYear().hashCode();
        int partition = hash % numPartitions;
        return partition;
    }
}
</terminal>

저기서 왜 해시가 나오고 해시를 나눈 나머지값을 반환하는지 전혀 이해할 수 없습니다.<br>
도대체 개발자 입장에선 해시값이란거 어떻게 할당되는지 당최 알 수 없는 부분인데 해시값을 쓰겠다니?!<br>
2007이 오고 그 다음에 2008이 왔는데 둘 다 해시값이 같으면 그냥 같은겁니다.<br>
아... 그런데 뒤에 numPartitions 라는걸로 나누는구나... 라고 생각하는데 역시나 무슨 의미인지 잘 모르겠습니다.<br>
음.... 파티션 번호를 생성한다라....<br>
자, 모든 년도가 숫자가 같든 다르든 해시값이 모두 같다고 쳐봅시다.<br>
그렇다면 저런식으로 파티션을 나눌 순 있겠습니다. 분명히.<br>
그런데 모두 다르다고 쳐봅시다.<br>
전부 다른 파티션으로 찢어져 나갈 것 아니겠습니까?....<br>
아... 역시 잘 모르겠습니다. 해시값을 쓰는 사람은 저보다 한단계 더 높은 사람인가봅니다.<br>
넘어가봅시다.<br>
<br>
<color4>GroupKeyComparator.java</color4>

<terminal>
package Airline;

import org.apache.hadoop.io.WritableComparable;
import org.apache.hadoop.io.WritableComparator;

import Airline.DateKey; // 역시나 넣어줘야 합니다.

public class GroupKeyComparator extends WritableComparator {

    protected GroupKeyComparator() {    // 이것도 마찬가지로 실행되자마 DateKey를 불러오겠다는 의미
        super (DateKey.class, true);
    }

    @SuppressWarnings("rawtypes")
    @Override
    public int compare(WritableComparable w1, WritableComparable w2) {
        DateKey k1 = (DateKey) w1;  // 강제 형 변환
        DateKey k2 = (DateKey) w2;  // 강제 형 변환

        return k1.getYear().compareTo(k2.getYear());    // 아까 받아온 줄과 지금 받아온 줄의 연도 비교
    }
}
</terminal>

리듀서에서 같은 연도에 해당하는 모든 데이터를 하나의 Reducer그룹에서 처리할 수 있게 해준답니다.<br>
쉽게 말해서 리턴값이 0이면 연도가 같구나 하고 계속 진행하는거고, 리턴값이 1이 나오면 연도가 올라갔구나 하고 새로 진행하는겁니다.<br>
뭐... 어떻게 쓰나 했더니 드라이버 클래스에서 다 사용해주네요...<br>
<br>
<color4>AirlineMapper.java</color4>

<terminal>
package Airline;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

import Airline.AirlineParser;
import Airline.DateKey;

public class AirlineMapper extends Mapper&lt;LongWritable, Text, DateKey, IntWritable&gt; {

    private IntWritable outputValue = new IntWritable(1);
    private DateKey outputKey = new DateKey();

    public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {

        AirlineParser parser = new AirlineParser(value);
        
        if (parser.isDepartureDelayAvailable()) {
            if (parser.getDepartureDelayTime() > 0) {
                outputKey.setYear("D," + parser.getYear());
                outputKey.setMonth(parser.getMonth());

                context.write(outputKey, outputValue);
            }
        }

        if (parser.isArriveDelayAvailable()) {
            if (parser.getArriveDelayTime() > 0) {
                outputKey.setYear("A," + parser.getYear());
                outputKey.setMonth(parser.getMonth());

                context.write(outputKey, outputValue);
            }
        }
    }
}
</terminal>

<color4>AirlineReducer.java</color4>

<terminal>
package Airline;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;

import Airline.DateKey;

public class AirlineReducer extends Reducer&lt;DateKey, IntWritable, DateKey, IntWritable&gt; {
    private MultipleOutputs&lt;DateKey, IntWritable&gt; mos;
    private DateKey outputKey = new DateKey();
    private IntWritable result = new IntWritable();

    @Override   // Reducer 클래스의 setup 함수를 오버라이드 합니다. 멀티파일로 저장해야 하기 때문이니까요.
    public void setup(Context context) throws IOException, InterruptedException {
        mos = new MultipleOutputs&lt;DateKey, IntWritable&gt;(context);
    }

    public void reduce(DateKey key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {

        int sum = 0;
        Integer bMonth = key.getMonth();

        if (key.getYear().substring(0, 1).equals("D")) {  // 출발 지연
            for (IntWritable value : values) {
                if (bMonth != key.getMonth()) {
                    result.set(sum);
                    outputKey.setYear(key.getYear().substring(2));
                    outputKey.setMonth(bMonth);
                    mos.write("departure", outputKey, result);
                    sum = 0;
                }
                sum += value.get();
                bMonth = key.getMonth();
            } 
            if (bMonth == key.getMonth()) {
                outputKey.setYear(key.getYear().substring(2));
                outputKey.setMonth(key.getMonth());
                result.set(sum);
                mos.write("departure", outputKey, result);
            }
        } else {    // 도착 지연
            for (IntWritable value : values) {
                if (bMonth != key.getMonth()) {
                    result.set(sum);
                    outputKey.setYear(key.getYear().substring(2));
                    outputKey.setMonth(bMonth);
                    mos.write("arrival", outputKey, result);
                    sum = 0;
                }
                sum += value.get();
                bMonth = key.getMonth();
            }
            if (bMonth == key.getMonth()) {
                outputKey.setYear(key.getYear().substring(2));
                outputKey.setMonth(key.getMonth());
                result.set(sum);
                mos.write("arrival", outputKey, result);
            }
        }
    }

    @Override   // Reducer클래스의 cleanup함수를 오버라이드 합니다. 멀티파일을 종료시켜야지요.
    public void cleanup(Context context) throws IOException, InterruptedException {
        mos.close();
    }
}
</terminal>

<color4>AirlineCountSort.java</color4>

<terminal>
package Airline;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;
import org.apache.hadoop.util.GenericOptionsParser;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;
import org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;

public class AirlineCountSort extends Configured implements Tool {

    public static void main(String[] args) throws Exception {
        int res = ToolRunner.run(new Configuration(), new AirlineCountSort(), args);
        System.out.println("Result : " + res);
    }

    public int run(String[] args) throws Exception {

        if (args.length != 2) {
            System.err.println("Usage: AirlineCount &lt;input&gt; &lt;output&gt;");
            System.exit(2);
        }

        Job job = new Job(getConf(), "AirlineCountSort");
        job.setJarByClass(AirlineCountSort.class);
        job.setPartitionerClass(GroupKeyPartitioner.class);
        job.setGroupingComparatorClass(GroupKeyComparator.class);
        job.setSortComparatorClass(DateKeyComparator.class);
        job.setMapperClass(AirlineMapper.class);
        job.setReducerClass(AirlineReducer.class);

        job.setInputFormatClass(TextInputFormat.class);
	    job.setOutputFormatClass(TextOutputFormat.class);

	    job.setOutputKeyClass(DateKey.class);
        job.setOutputValueClass(IntWritable.class);

        FileInputFormat.addInputPath(job, new Path(args[0]));
	    FileOutputFormat.setOutputPath(job, new Path(args[1]));
        
        MultipleOutputs.addNamedOutput(job, "departure", TextOutputFormat.class, DateKey.class, IntWritable.class);    // departure로 시작하는 파일을 생성하여 저장함
        MultipleOutputs.addNamedOutput(job, "arrival", TextOutputFormat.class, DateKey.class, IntWritable.class);      // arrival로 시작하는 파일을 생성하여 저장함

        job.waitForCompletion(true);
        return 0;
    }
}
</terminal>

다 작성했으면 컴파일을 합시다.<br>

<terminal>
<strong>[hadoop@namenode sort]$</strong> javac -cp $HADOOP_HOME/hadoop-core-1.2.1.jar -d . *.java
<strong>[hadoop@namenode sort]$</strong> jar -cvf $HADOOP_HOME/AirlineCountSort.jar ./Airline/*.class
Manifest를 추가함
추가하는 중: Airline/AirlineCount.class(입력 = 2775) (출력 = 1292)(53%를 감소함)
추가하는 중: Airline/AirlineMapper.class(입력 = 2345) (출력 = 1003)(57%를 감소함)
추가하는 중: Airline/AirlineParser.class(입력 = 2223) (출력 = 1079)(51%를 감소함)
추가하는 중: Airline/AirlineReducer.class(입력 = 3244) (출력 = 1293)(60%를 감소함)
추가하는 중: Airline/DateKey.class(입력 = 2058) (출력 = 925)(55%를 감소함)
추가하는 중: Airline/DateKeyComparator.class(입력 = 763) (출력 = 467)(38%를 감소함)
추가하는 중: Airline/GroupKeyComparator.class(입력 = 572) (출력 = 348)(39%를 감소함)
추가하는 중: Airline/GroupKeyPartitioner.class(입력 = 753) (출력 = 423)(43%를 감소함)
<strong>[hadoop@namenode sort]$</strong> cd $HADOOP_HOME
<strong>[hadoop@namenode hadoop]$</strong> ./bin/hadoop jar AirlineCountSort.jar Airline.AirlineCountSort airplain/2008.csv airline_sort
</terminal>

이번에는 전부 패키지명을 넣고 자바 파일을 만들었기 때문에 실행할 때 패키지명.클래스명 이렇게 해주셔야 합니다.<br>
다 되고나면 윌별로 잘 정리되었나 한번 확인해보겠습니다.<br>

<terminal>
<strong>[hadoop@namenode hadoop]$</strong> ./bin/hadoop fs -ls airline_sort
Found 5 items
-rw-r--r--   3 hadoop supergroup          0 2018-01-28 00:44 /user/hadoop/airline_sort/_SUCCESS
drwxr-xr-x   - hadoop supergroup          0 2018-01-28 00:43 /user/hadoop/airline_sort/_logs
-rw-r--r--   3 hadoop supergroup        171 2018-01-28 00:44 /user/hadoop/airline_sort/arrival-r-00000
-rw-r--r--   3 hadoop supergroup        171 2018-01-28 00:44 /user/hadoop/airline_sort/departure-r-00000
-rw-r--r--   3 hadoop supergroup          0 2018-01-28 00:44 /user/hadoop/airline_sort/part-r-00000
<strong>[hadoop@namenode hadoop]$</strong> ./bin/hadoop fs -cat airline_sort/departure-r-00000 | head -10
2008	1	247948
2008	2	252765
2008	3	271969
2008	4	220864
2008	5	220614
2008	6	271014
2008	7	253632
2008	8	231349
2008	9	147061
2008	10	162531
<strong>[hadoop@namenode hadoop]$</strong> ./bin/hadoop fs -cat airline_sort/arrival-r-00000 | head -10
2008	1	279427
2008	2	278902
2008	3	294556
2008	4	256142
2008	5	254673
2008	6	295897
2008	7	264630
2008	8	239737
2008	9	169959
2008	10	183582
</terminal>

1 다음에 10이 안오고 숫자 순서대로 나열됐습니다.<br>
아마도 여기에 대해서 이걸 왜 하냐 R로 시각화 하면 알아서 정렬되지 않냐 라고 하시는 분들도 간혹 계실겁니다.<br>
그런데 여러분, 아까도 제가 언급했듯이, 시각화 외에 정확한 수치가 필요해서 저걸 다 뽑아야 하는 경우도 있을겁니다.<br>
정확한 비교를 위해서요.<br>
그런 경우엔 꼭 정렬이 잘 되어있어야 비교가 수월 할 겁니다.<br>
여기까지 보조 정렬에 대해 알아보았고, 다음 글에서는 부분 정렬에 대해서 알아보도록 하겠습니다.<br>
<br>
<a href="/hadoop/page/2_5.html" onclick="
    event.preventDefault();

    let xhttp = new XMLHttpRequest();

    xhttp.onreadystatechange = () => {
        document.querySelector('main').innerHTML = xhttp.responseText;
    }

    xhttp.open('GET', '/hadoop/page/2_5.html', true);
    xhttp.send();

    document.title = 'Hadoop Guide Part. 2 - Step. 5';
    history.pushState('/hadoop/page/2_5.html' + ' ' + 'Part. 2 - Step. 5', null, '#2_5');

    document.querySelector('side').children[1].classList.add('on');
    document.querySelector('side').children[1].children[4].classList.remove('on');
    document.querySelector('side').children[1].children[5].classList.add('on');
" class="button">다음단계로 가기</a>